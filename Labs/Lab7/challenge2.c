#pragma config(Sensor, S1,     touchRight,     sensorEV3_Touch)
#pragma config(Sensor, S2,     touchLeft,      sensorEV3_Touch)
#pragma config(Sensor, S3,     ultraSonic,     sensorEV3_Ultrasonic)
#pragma config(Sensor, S4,     gyroSensor,     sensorEV3_Gyro)
#pragma config(Motor,  motorB,          leftMotor,     tmotorEV3_Large, PIDControl, driveLeft, encoder)
#pragma config(Motor,  motorC,          rightMotor,    tmotorEV3_Large, PIDControl, driveRight, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// Wheel circumfrance
#define circumfrance 17.27

// Function prototypes
void turn90(long power);
void reset();
void driveUntilBump(long power);
void driveUntilWall(long power);
void drive(long nMotorRatio, long dist, long power);

task main()
{
	// Drive until a bump is detected
	driveUntilBump(30);

	// Turn 90 degrees to the left
	turn90(15);

	// Drive until ultrasonic detects a wall
	driveUntilWall(30);

	// Turn 90 degrees to the left
	turn90(15);

	// Drive until ultrasonic detects a wall
	driveUntilWall(30);


	// Turn 90 degrees to the left
	turn90(15);


	// Drive 30cm at 15 power
	drive(0, 30, 15);
}


// Reset motor encoders to 0
void reset()
{
	resetMotorEncoder(leftMotor);
	resetMotorEncoder(rightMotor);
}


// Drive until robot detects bump, then reverse
void driveUntilBump(long power)
{
	// While no bump detected, drive at power
	while(!SensorValue(touchLeft) && !SensorValue(touchRight))
	{
		setMotorSync(leftMotor, rightMotor, 0, power);
	}

	// Reverse for 0.5 seconds
	setMotorSync(leftMotor, rightMotor, 0, -power);
	sleep(500);
}


// 90 degree left turn using a gyro
void turn90(long power)
{
	// Reset gyro to 0
	resetGyro(gyroSensor);

	// Turn until 90 degrees, 80 set due to accuracy issues
	while(SensorValue[gyroSensor] > -80)
	{
		displayBigTextLine(4, "%d", getGyroDegrees(gyroSensor));
		setMotorSync(leftMotor, rightMotor, -100, power);
	}
}


// Drive until a wall is sensed at set power
void driveUntilWall(long power)
{
	while(getUSDistance(ultraSonic) > 10)
	{
		setMotorSync(leftMotor, rightMotor, 0, power);
	}
}


// Drive a distance at a given ratio, to any set power level
void drive(long nMotorRatio, long dist, long power)
{
		// Rotations needed to drive the distance
		float rotations = 360 * (dist / circumfrance);

		// reset encoders
		reset();

		// Drive the given distance at the set power
		setMotorSyncEncoder(leftMotor, rightMotor, nMotorRatio, rotations, power);
		waitUntilMotorStop(leftMotor);
}
