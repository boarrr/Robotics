#pragma config(Motor,  motorB,          leftMotor,     tmotorEV3_Large, PIDControl, driveLeft, encoder)
#pragma config(Motor,  motorC,          rightMotor,    tmotorEV3_Large, PIDControl, driveRight, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#define circumfrance 17.27

void drive(long nMotorRatio, long dist, long power);
void turn90(char direction, long power);
void square(int perimeter);
void returnSlow(int distance);
void reset();


task main()
{
	// Do a square of perimiter 240cm
	square(240);

	// Drive 100cm and return slowly
	returnSlow(100);
}


// Reset encoders
void reset()
{
	resetMotorEncoder(leftMotor);
	resetMotorEncoder(rightMotor);
}


// Drive a distance at a ratio, to a set power level
void drive(long nMotorRatio, long dist, long power)
{
		float rotations = 360 * (dist / circumfrance);

		reset();

		setMotorSyncEncoder(leftMotor, rightMotor, nMotorRatio, rotations, power);
		waitUntilMotorStop(leftMotor);
}


// Negative for left turn, positive int for right turn
void turn90(char direction, long power)
{
	reset();

	// Check direction for rotation
	if (direction == 'l'  || direction == 'L')
	{
		// Turn 180 degrees of wheel rotation
		setMotorSyncEncoder(leftMotor, rightMotor, 100, 180, power);
		waitUntilMotorStop(leftMotor);
	}
	else if (direction == 'r'  || direction == 'R')
	{
		// Turn 180 degrees of wheel rotation
		setMotorSyncEncoder(leftMotor, rightMotor, -100, 180, power);
		waitUntilMotorStop(leftMotor);
	}
}


// Do a square with a set perimeter in a random direction
void square(int perimeter)
{
	int sideLength = perimeter / 4;
	int randInt = random(1);
	char direction;


	if (randInt == 0)
	{
		direction = 'l';
	}
	else
	{
		direction = 'r';
	}

	// Square logic, 4 sides in a square
	for(int i = 0; i < 4; i++)
	{
		drive(0, sideLength, 50);
		sleep(200);
		turn90(direction, 50);
	}
}


// Go to distance, 180 and return slow
void returnSlow(int distance)
{
	drive(0, distance, 100);
	sleep(200);

	turn90('r', 50);
	turn90('r', 50);

	sleep(200);

	drive(0, distance, 25);
}
