#pragma config(Sensor, S1,     ultraSonic,     sensorEV3_Ultrasonic)
#pragma config(Sensor, S2,     touchLeft,      sensorEV3_Touch)
#pragma config(Sensor, S3,     touchRight,     sensorEV3_Touch)
#pragma config(Motor,  motorB,          leftMotor,     tmotorEV3_Large, PIDControl, driveLeft, encoder)
#pragma config(Motor,  motorC,          rightMotor,    tmotorEV3_Large, PIDControl, driveRight, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#define circumfrance 17.27

void turn90(char direction, long power);
void reset();
void driveUntilBump(long power);
void driveUntilWall(long power);
void drive(long nMotorRatio, long dist, long power);

task main()
{
	driveUntilBump(75);

	turn90('l', 50);

	driveUntilWall(75);

	turn90('l', 50);

	driveUntilWall(75);

	turn90('l', 50);

	drive(0, 30, 50);

}


void reset()
{
	resetMotorEncoder(leftMotor);
	resetMotorEncoder(rightMotor);
}


// Drive until detects bump, and reverse
void driveUntilBump(long power)
{
	while(!SensorValue(touchLeft) && !SensorValue(touchRight))
	{
		setMotorSync(leftMotor, rightMotor, 0, power);
	}

	setMotorSync(leftMotor, rightMotor, 0, -50);
	sleep(500);
}


// Negative for left turn, positive int for right turn
void turn90(char direction, long power)
{
	reset();

	// Check direction for rotation
	if (direction == 'l'  || direction == 'L')
	{
		// Turn 180 degrees of wheel rotation
		setMotorSyncEncoder(leftMotor, rightMotor, 100, 180, power);
		waitUntilMotorStop(leftMotor);
	}
	else if (direction == 'r'  || direction == 'R')
	{
		// Turn 180 degrees of wheel rotation
		setMotorSyncEncoder(leftMotor, rightMotor, -100, 180, power);
		waitUntilMotorStop(leftMotor);
	}
}


// Drive until a wall is sensed at set power
void driveUntilWall(long power)
{
	while(getUSDistance(ultraSonic) > 10)
	{
		setMotorSync(leftMotor, rightMotor, 0, power);
	}
}


// Drive a distance at a ratio, to a set power level
void drive(long nMotorRatio, long dist, long power)
{
		float rotations = 360 * (dist / circumfrance);

		reset();

		setMotorSyncEncoder(leftMotor, rightMotor, nMotorRatio, rotations, power);
		waitUntilMotorStop(leftMotor);
}
